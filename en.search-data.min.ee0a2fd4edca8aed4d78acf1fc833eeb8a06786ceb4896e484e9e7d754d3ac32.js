'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/interview/arch/session/',title:"Session",section:"Arches",content:"Session #   究竟如何保证session一致性？\n"}),a.add({id:1,href:'/interview/candidate/demo/',title:"Demo",section:"Candidates",content:"Phone Interview Questions About You #  Tell me about yourself. #  　Good afteernoon, I will appreciate it that you give me an opportunity to introduce myself now.\nMy name is xxx zhang, and you can call me dean in english.\nI come from shenzhen. Now I am a sre engernier and I\u0026rsquo;m working for xx now, which is the best degtail bank online of china.\nI had worked for xx in 2 years ago. That\u0026rsquo;s My major is SRE, which make the site releable.\nauto-scaling, capacity, reliable and high performance are my focus on\nI am not only good at my major but also English .\nI will do my best in my working if you can give me the chance. That\u0026rsquo;s all. Thanksfor your listening.\nDo you know shopee? #  Shopee is the best online shoping platform under The Sea Group. It first launched in Singapore in 2015, since expanded its reach to Malaysia, Thailand, Taiwan, Philippines and many counties in Southeast Asia.\nIt is the leading e-commerce online shopping platform in Southeast Asia and Taiwan. It provides customers with an easy, secure and fast online shopping \u0026hellip;\nWith the best shoping experice, many static cumstomers\nIt serves users in Southeast Asia and Taiwan to buy and sell products online.\nSea AirPay\nIn fact, chinese mainland aslo have the service, like jd, alibaba, etc\u0026hellip;\nQ：Can you sell yourself in two minutes？ Go for it. （你能在两分钟内自我推\u2028荐吗？大胆试试吧！）\u2028A： With my qualifications and experience, I feel I am hardworking,\u2028responsible and diligent in any project I undertake.\nYour organization could\u2028benefit from my analytical and interpersonal skills. (依我的资格和经验，我觉\u2028得我对所从事的每一个项目都很努力、负责、勤勉。我的分析能力和与人相处的技巧，\u2028对贵单位必有价值。)\nA： With my strong techlogical background, I am capable and competent. (凭借我\u2028良好的学术背景，我可以胜任自己的工作，而且我认为自己很有竞争力。）\nGive me a summary of your current job description. (对你目前的工作，能否\u2028做个概括的说明。)\u2028\u2028A：I have been working as a computer programmer for 7 years. To be\u2028specific, I do system analysis, trouble shooting and provide software\u2028support. (我干了五年的电脑程序员。具体地说，我做系统分析，解决问题以及软件供\u2028应方面的支持。）\u2028Q：Why did you leave your last job？(你为什么离职呢？)\u2028A： Well, I am hoping to get an offer of a better position. If opportunity\u2028knocks, I will take it.（我希望能获得一份更好的工作，如果机会来临，我会抓\u2028住。）\u2028A：I feel I have reached the \u0026ldquo;glass ceiling\u0026rdquo; in my current job. / I feel\u2028there is no opportunity for advancement. （我觉得目前的工作，已经达到顶峰，\u2028即没有升迁机会。)\nQ：What is your strongest trait(s)？(你个性上最大的特点是什么？)\u2028A：Helpfulness and caring.（乐于助人和关心他人。）\u2028A：Adaptability and sense of humor.（适应能力和幽默感。）\u2028A：Cheerfulness and friendliness.（乐观和友爱。）\u2028What are your great strengths?\u2028你有什么优点？\u2028I’m a good team player.\u2028我是一个富有团队精神的人。\u2028I’m a hard-working, persistent person.\u2028我工作刻苦，性情执着。\u2028I’m a fast-learner.\u2028我学东西很快。\nI can work under pressure and get along with my colleagues.\u2028我能在压力下工作，并能与同事和谐相处。\u2028I have strong organizational skills.\u2028我的组织能力很强。\nGoals for the Future?英语面试：职业规划 My long-term goals is be a greatest programer, software architect,\nCreate some star opensource projects\na typical career path for someone with my skills and experiences?\n需要避免的8个常见错误 #  1.想着这不是一个真正的面试\n2.没有提前准备\n3.在并不安静的地方接电话\n4.使用不稳定的电话网络\n5.没有特别注意你的声调\n6.没有准备好应对典型的筛选问题，例如你能够入职的时间和薪酬预期\n7.没有把你的申请材料发在手边\n8.允许自己分心\nhttps://www.w3cschool.cn/xca2dq/8wd212h4.html\n"}),a.add({id:2,href:'/interview/candidate/github-question/',title:"Github Question",section:"Candidates",content:"Github 面试题 #  #   计算机基础\n 数据结构与算法\n Go语言面试问答\n"}),a.add({id:3,href:'/interview/candidate/Phone-Interview-Questions-About-the-New-Job-and-the-Company/',title:"Phone Interview Questions About the New Job and the Company",section:"Candidates",content:"Phone Interview Questions About the New Job and the Company #  What interests you about this job? #  Why do you want this job? #  What applicable attributes/experience do you have? #  Are you overqualified for this job? #  What can you do for this company? #  What do you know about this company? #  Why do you want to work here? #  What challenges are you looking for in a position? #  What can you contribute to this company? #  Are you willing to travel? #  Is there anything I haven\u0026rsquo;t told you about the job or company that you would like to know? #  "}),a.add({id:4,href:'/interview/candidate/Phone-Interview-Questions-About-You/',title:"Phone Interview Questions About You",section:"Candidates",content:"Phone Interview Questions About You #  Tell me about yourself. #  What are you looking for in your next job? What is important to you? #  What is your greatest weakness? #  What is your greatest strength? #  Describe a typical work week. #  How would you describe the pace at which you work? #  How do you handle stress and pressure? #  What motivates you? #  Questions about your career goals. #  What type of work environment do you prefer? #  How do you evaluate success? #  Job interview questions about your abilities. #  More job interview questions about you. #  "}),a.add({id:5,href:'/interview/candidate/Phone-Interview-Questions-About-Your-Background/',title:"Phone Interview Questions About Your Background",section:"Candidates",content:"Phone Interview Questions About Your Background #  Work history questions: name of company, job title and job description, dates of employment. #  What were your starting and final levels of compensation? #  What were your responsibilities? #  What major challenges and problems did you face? How did you handle them? #  Why are you leaving your job? #  What are your salary expectations? #  "}),a.add({id:6,href:'/interview/candidate/solution/',title:"Solution",section:"Candidates",content:"运维问题 #  磁盘告警 #  CPU 高 #  数据不一致 #  "}),a.add({id:7,href:'/interview/interviewer/e1/',title:"E1",section:"Interviewers",content:"Interview Questions For Engineers #  面试官注意事项： #   问题之间最好有连续性，有过渡阶段，由浅到深。 面试节奏不应过快，可以多问一些做过或了解的东西，一般online coding做不完。 面试官应该提前准备好面试问题，以及对应答案或是代码。 回答候选人问题时，切不可说工作内容和面试内容的问题。 做好沟通，确认候选人听懂问题。编程题目，一定要提前给出输入和期待输出，编程前提前沟通思路。  Reference #   Written interview knowledge - zh\n What happens when - zh\n AI\n Interview internal reference\n Reverse interview zh\n go语言之行\u0026ndash;golang核武器goroutine调度原理、channel详解\n leetcode golang实现\n The-Art-Of-Programming\n 树形结构数据存储方案（二）： 物化路径\n"}),a.add({id:8,href:'/interview/interviewer/evaluation/',title:"Evaluation",section:"Interviewers",content:"面试官评价关键词 #  英文评价 #  He can express his idea in Golang properly.\n 他可以正确的表达自己的想法。  Overall, his technical skill meet the expectation\n 总体来说，技术水平符合标准。  CDD\u0026rsquo;s programming skill is average, he can explain the idea and can implement within the timeline(30 minutes).\n 候选人编程能力还可以，他可以在说清楚自己的想法，并且在指定的时间内完成编程。  负面评价 #  It is a bit hard for him to get the question and to explain his ideas.\n 他不能理解问题，讲不清自己的想法。  And he also could not explain his own project clearly.\n 而且无法讲清楚自己的做过的项目。  评价短语 #  Fairly well 相当不错\nbear the burden\n 承担重任  lacks of depth\n 缺乏深度  mainly work is\n 主要工作是\u0026hellip;  "}),a.add({id:9,href:'/interview/interviewer/q1/',title:"Q1",section:"Interviewers",content:"xxx #   TCP 结束的过程，请大概描述一下？ TimeWait 的作用是什么，有遇到过相关问题吗？ LINUX 进程有哪些状态，初步讲一下。 TOP 中CPU 的使用率， 这值是怎么回事，从哪来的？  "}),a.add({id:10,href:'/interview/network/tcp-state/',title:"Tcp State",section:"Networks",content:"TCP state in OS #  TCP 的状态 #  ![tcp-status](images/tcp-status.jpg)   1、客户端独有的：（1）SYN_SENT （2）FIN_WAIT1 （3）FIN_WAIT2 （4）CLOSING （5）TIME_WAIT 。\n  2、服务器独有的：（1）LISTEN （2）SYN_RCVD （3）CLOSE_WAIT （4）LAST_ACK 。\n  3、共有的：（1）CLOSED （2）ESTABLISHED 。\n 各个状态的意义如下： LISTEN - 侦听来自远方TCP端口的连接请求； SYN-SENT -在发送连接请求后等待匹配的连接请求； SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； FIN-WAIT-2 - 从远程TCP等待连接中断请求； CLOSE-WAIT - 等待从本地用户发来的连接中断请求； CLOSING -等待远程TCP对连接中断的确认； LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； CLOSED - 没有任何连接状态； TCP连接过程是状态的转换，促使发生状态转换的是用户调用： OPEN，SEND，RECEIVE，CLOSE，ABORT和STATUS   1、建立连接协议（三次握手）\n （1）客户 端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的报文1。 （2） 服务器端回应客户端的，这是三次握手中的第2个报文，这个报文同时带ACK标志和SYN标 志。因此它表示对刚才客户端SYN报文的回应；同时又标志SYN给客户端，询问客户端是否准备好进行数据通 讯。 （3） 客户必须再次回应服务段一个ACK报文，这是报文段3。   2、连接终止协议（四次握手）\n 　由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终 止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接 在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。   　（1） TCP客 户端发送一个FIN，用来关闭客户到服务器的数据传送（报文段4）。\n  　（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一 样，一个FIN将占用一个序号。\n  　（3） 服务器关闭客户端的连接，发送一个FIN给客户端（报文段6）。\n  　（4） 客户段发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。\n CLOSED: 这个没什么好说的了，表示初始状态。 LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处 于监听状态，可以接受连接了。 SYN_RCVD: 这个状态表示接受到了SYN报 文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手 过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文 后，它会进入到ESTABLISHED状态。 SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 ESTABLISHED：这个容易理解了，表示连接已经建立了。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报 文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况 下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。 FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点 数据需要传送给你，稍后再关闭连接。 TIME_WAIT: 表示收到了对方的FIN报 文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标 志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发 送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报 文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报 文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一 个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一 个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文 给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话， 那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。 LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报 文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。 最后有2个问题 的回答，我自己分析后的结论（不一定保证100%正确）   1、 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起 应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文 通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文 和FIN报文多数情况下都是分开发送的。\n  2、 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 这是因为：虽然双方 都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状 态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报 文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报 文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报 文，并保证于此。\n  断开连接的时候， 当发起主动关闭的左边这方发送一个FIN过去后， 右边被动关闭的这方要回应一个ACK，这个ACK是TCP回应的，而不是应用程序发送的，此时，被动关闭的一方就处于CLOSE_WAIT状态了。 如果此时被动关闭的这一方不再继续调用closesocket,那么他就不会发送接下来的FIN，导致自己老是处于CLOSE_WAIT。 只有被动关闭的这一方调用了 closesocket,才会发送一个FIN给主动关闭的这一方，同时也使得自己的状态变迁为LAST_ACK。  "}),a.add({id:11,href:'/interview/network/tcp/',title:"Tcp",section:"Networks",content:"TCP/IP 基础理论 #  TCP #  From: 一文彻底搞懂 TCP三次握手、四次挥手过程及原理\nForm: 面试官：换人！他连 TCP 这几个参数都不懂\nForm: 为什么 TCP 协议有 TIME_WAIT 状态\n"}),a.add({id:12,href:'/interview/os/os/',title:"Os",section:"Os",content:"OS #  进程和线程、协程的区别 #  一、概念\n 　1、进程: 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。\n  　2、线程: 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。\n  　3、协程: 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n 二、区别：\n 1、进程多与线程比较: 线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:\n  1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间 2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源 3) 线程是处理器调度的基本单位,但进程不是 4) 二者均可并发执行 5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制   2、协程多与线程进行比较\n  1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。 2) 线程进程都是同步机制，而协程则是异步 3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态  "}),a.add({id:13,href:'/interview/programming/1-cartesian-product/',title:"1 Cartesian Product",section:"Programmings",content:"求笛卡尔积 #  Q: 求 [\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;, \u0026ldquo;y\u0026rdquo;], [1, 2, 3] 的迪卡尔积。 #  1. python 版本 #  #!/usr/bin/env python #-*-coding:utf-8-*- import itertools a = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;] b = [\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;] c = [1, 2, 3] # 计算笛卡尔积 # Param : 以单个集合(数组)作为参数，可以支持变长参数，即多个集合。 # Return: 返回组合的个数及对应的数组集合 def combination(*array): # 错误处理, 如果当只有一个集合进行计算，则抛出异常 if len(array) \u0026lt; 2: raise ValueError(\u0026quot;至少有2个集合\u0026quot;) if len(array) \u0026gt; 12: print(\u0026quot;数据量较大，生成集合耗时较长, 请耐心等待\u0026quot;) count = 0 items = [] for item in itertools.product(*array): count += 1 print item items.append(item) return (count, items) if __name__ == '__main__' : print \u0026quot;笛卡尔积：\u0026quot; # 如果有多少集合数据，可以',' 分隔作为参数传递给函数combination(), 如combination(a1, a2, a3, a4, ...) # count, items = combination(a, b, c, a, b, c, a, b, c, a, b, c) # count, items = combination(a) count, items = combination(a, b, c) print \u0026quot;此笛卡尔积组合为: \u0026quot;, items print \u0026quot;共有 %d 个组合\u0026quot; % (count)  2. golang 版本 #  package main import ( \u0026quot;errors\u0026quot; \u0026quot;fmt\u0026quot; ) // 递归下一个 index func NextIndex(idx []int, lenArr []int) { j := len(idx) - 1 for ; j \u0026gt;= 0; j-- { fmt.Println(\u0026quot;debug========:\u0026quot;, j, idx) idx[j]++ fmt.Println(\u0026quot;debug========:\u0026quot;, j, idx) if j == 0 || idx[j] \u0026lt; lenArr[j] { return } // 首次返回0下标 idx[j] = 0 } } func Combination(arr ...[]string) (count int, arrList [][]string, err error) { // 错误处理, 少于2个集合则错误返回。 if len(arr) \u0026lt; 2 { fmt.Println(\u0026quot;至少有2个集合\u0026quot;) errors.New(\u0026quot;至少有2个集合\u0026quot;) count = -1 return } // 将每一个集合的长度记录下来, 并存放在数组中 lenArray := []int{} for index, _ := range arr { lenArray = append(lenArray, len(arr[index])) } // 构造索引数组, 并初始化[], 值为0 idx := make([]int, len(arr)) // 索引数组中索引小于集合长度进行循环, 从右往左依次增加下标idx数值，实现遍历。 for ; idx[0] \u0026lt; lenArray[0]; NextIndex(idx, lenArray) { var r []string for j, k := range idx { fmt.Println(\u0026quot;debug2======\u0026quot;, r, j, k, idx) // 依次合并相邻集合，最终所有元素存放在r数组中 r = append(r, arr[j][k]) } fmt.Println(r) arrList = append(arrList, r) } count = len(arrList) return } func main() { arr1 := []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;} arr2 := []string{\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;} arr3 := []string{\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;} // Combination(arr1, arr2, arr3, arr1) count, arrList, err := Combination(arr1, arr2, arr3, arr1) // count, arrList, err := Combination(arr1) if err == nil { fmt.Printf(\u0026quot;笛卡尔积组合为：%s, 共有：%d 个组合\\n\u0026quot;, arrList, count) } }  "}),a.add({id:14,href:'/interview/programming/2-lru/',title:"2 Lru",section:"Programmings",content:"LRU CACHE IMPLEMENTATION IN GO #  https://girai.dev/blog/lru-cache-implementation-in-go/\n"}),a.add({id:15,href:'/interview/README/',title:"Readme",section:"home",content:"This is an example. #  s1 #  s1 demo\ns2 #  s2 demo\n"})})()